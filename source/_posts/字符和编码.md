---
title: 字符和编码
date: 2022-03-26 09:26:15
desc: 弄懂编码
tags: 字符
---

### 引言

<!-- 手握锟斤拷，直呼烫烫烫。 -->
计算机中的存储器唯一可以存储的是bit(0/1)，如果想要在计算机上处理信息，就必须把它按位存储。因此为了将文本表示为数字形式，我们需要构建一个系统来为每一个字符赋予一个独一无二的ID。

具有这种功能的系统被称为**字符集（Charset**。其实字符集就是一个map，一个字符到表示这个字符的唯一ID[这些Id就被称作**码点**(**code point**)]的映射集合。有了字符集合我们就将文本映射成数字形式。但是需要一个规则用来规定如何在计算机中存储这些数字(使用多少字节?)，于是我们就有了**字符编码(encoding)**。

### ASCII

在计算机早期应对的字符场景还很简单(大小写拉丁字母(26 * 2 = 52) + 数字0-9(10) + 一些符号 不超过128个)，因此于1963发布的ASCII是可以应付当时的场景。

![image-20220319234553566](https://chromer-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20220319234553566-7a392a5b7a2cc1732cf7b30c53275155f1e07969dbffd478ebd8d0a7e675409a.png)

标准ASCII只用到的1byte的后7位。看下图就可以知道ASCII使用范围是$0x00$ ~ $ 0x7F$。

![](https://chromer-blog.oss-cn-shanghai.aliyuncs.com/blog/USASCII_code_chart-9e9c85c0d5f0c819bcf7d61c0cce9152e0e359b2cffe96d2b5507b690edafc20.png)



### Unicode

随着计算机的发展和互联网的普及，计算机需要面对各个国家的语言。此时ASCII很显然无法满足需求了，于是各个国家都发布了自己语言的字符集，我们国家也是在1980年发布了基于ASCII扩展的中文字符集[**GB2312**](https://zh.wikipedia.org/wiki/GB_2312)。

于是建立一个涵盖世界上所有文本的编码规范成为了一个迫切的需求。在国际化标准组织和美国几大商业公司合作下，1991年Unicode发布。

最初的Unicode编码使用16位的编码空间也就是2Byte这样理论上最多可以表示$2^{16}$(即65536)个字符，显然这样要表示世界上所有语言中的字符是远远不够的。后来在Unicode4.0规范中考虑到了这种情况，定义了一组附加字符编码，附加字符编码使用2个16位表示，目前Unicode编码范围是U+0000~U+10FFFF。

Unicode将这些码点按照每组$2^{16}$（65536）分组，每组被称为一个**平面**（plane）。Unicode一共将这些码点分成了17个平面，Plane0 ~ Plane16。Plane0又被称作基本多文本平面（BMP)，其他平面统称为辅助平面。

| 平面              | 范围                | 中文名称                  | 英文名称 |
| ----------------- | ------------------- | ------------------------- | -------- |
| 0号平面（Plane0)  | U+0000 - U+FFFF     | 基本多文本平面            | BMP      |
| 1号平面（Plane1)  | U+10000 - U+1FFFF   | 多文种补充平面            | SMP      |
| 2号平面(Plane2)   | U+20000 - U+2FFFF   | 表意文字补充平面          | SIP      |
| 3号平面(Plane3)   | U+30000 - U+3FFFF   | 表意文字第三平面          | TIP      |
| 4号平面~13号平面  | U+40000 - U+DFFFF   | 未使用                    |          |
| 14号平面(Plane14) | U+E0000 - U+EFFFF   | 特别用途补充平面          | SSP      |
| 15号平面(Plane15) | U+F0000 - U+FFFFF   | 保留作为私人使用区（A区） | PUA-A    |
| 16号平面(Plane16) | U+100000 - U+10FFFF | 保留作为私人使用区（B区） | PUA-B    |
|                   |                     |                           |          |

![image-20220319235230869](https://chromer-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20220319235230869-4dcab2527238d5c0bdd623f6f8ea4330eb69877a02626bfd8a4cab02f41a1d00.png)



### Unicode编码方案

Unicode 没有规定字符对应的二进制码如何存储。以汉字“汉”为例，它的 Unicode 码点是 0x6c49，对应的二进制数是 110110001001001，二进制数有 15 位，这也就说明了它至少需要 2 个字节来表示。可以想象，在 Unicode 字典中往后的字符可能就需要 3 个字节或者 4 个字节，甚至更多字节来表示了。

这就导致了一些问题，计算机怎么知道你这个 2 个字节表示的是一个字符，而不是分别表示两个字符呢？这里我们可能会想到，那就取个最大的，假如 Unicode 中最大的字符用 4 字节就可以表示了，那么我们就将所有的字符都用 4 个字节来表示，不够的就往前面补 0（UTF-32)。这样确实可以解决编码问题，但是却造成了空间的极大浪费，如果是一个英文文档，那文件大小就大出了 3 倍，这显然是无法接受的。

于是，为了较好的解决 Unicode 的编码问题， UTF-8 和 UTF-16 两种当前比较流行的编码方式诞生了。当然还有一个 UTF-32 的编码方式，也就是上述那种定长编码，字符统一使用 4 个字节，虽然看似方便，但是却不如另外两种编码方式使用广泛。

### UTF-8

UTF-8 是一个非常惊艳的编码方式，漂亮的**实现了对 ASCII 码的向后兼容**，以保证 Unicode 可以被大众接受。

**UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式**，它的最大特点就是**可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度**。编码规则如下：

1. 对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。
2. 对于需要使用 N 个字节来表示的字符（N > 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为 0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。

编码规则如下：

| Unicode 十六进制码点范围 | UTF-8 二进制                        |
| :----------------------- | :---------------------------------- |
| 0000 0000 - 0000 007F    | 0xxxxxxx                            |
| 0000 0080 - 0000 07FF    | 110xxxxx 10xxxxxx                   |
| 0000 0800 - 0000 FFFF    | 1110xxxx 10xxxxxx 10xxxxxx          |
| 0001 0000 - 0010 FFFF    | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |



#### 编码过程

下图展示了中文“我”的UTF-8的编码过程，最终得到的结果是0xE68891

![image-20220320174733759](https://chromer-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20220320174733759-4e87c30dcf657497ade3913b1b7a6fb0c478f49d0e06f39ae13531ed1e06c12e.png)

![image-20220326225545448](https://chromer-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20220326225545448-e03623515fcac258c665e877a9acff55d58af34568edb349df8d9b4fa2ebe60d.png)



### UTF-16

UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时**结合了定长和变长两种编码方法的特点**。它的编码规则很简单：**基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节**。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。那么问题来了，当我们遇到两个字节时，到底是把这两个字节当作一个字符还是与后面的两个字节一起当作一个字符呢？

这里有一个很巧妙的地方，在基本平面内，从 U+D800 到 U+DFFF ($2^{11}$)是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。

辅助平面的字符位共有 $2^{20}$ 个，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF（空间大小 $2^{10}$），称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF（空间大小 $2^{10}$），称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。

因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解码。

下面以古汉字“𠮷”为例，展示下UTF-16编码过程。

![image-20220326234610643](https://chromer-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20220326234610643-dcc8023249489b472b7294466b55c330cafe40e3155c5e980efb6cf221771058.png)