<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CJS是如何处理循环依赖的 · Chromer's Blog</title><meta name="description" content="CJS是如何处理循环依赖的 - chromer"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://narutohinata.github.io/atom.xml" title="Chromer's Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Chromer's Blog" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">Chromer's Blog</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>INDEX</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>ARCHIVES</p></a><a href="/tags" target="_self" class="li component-nav-item"><p>TAGS</p></a><a href="/categories" target="_self" class="li component-nav-item"><p>CATEGORIES</p></a><ul class="shortcut-icons"><a href="https://github.com/narutohinata" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">CJS是如何处理循环依赖的</h1><div class="post-info">2020年1月1日</div><div class="post-content"><h2 id="Commonjs是如何解决循环依赖"><a href="#Commonjs是如何解决循环依赖" class="headerlink" title="Commonjs是如何解决循环依赖"></a>Commonjs是如何解决循环依赖</h2><p>要回答这个问题我们先了解下<code>cjs</code> 的模块加载流程。当加载一个<code>cjs</code> 模块的时候会先缓存模块对象 <code>Module._cache[filename] = module</code>  然后再加载模块 <code>module.load(filename)</code> 。基于这个模块加载流程我们分析下面这个循环依赖的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.js</span></span><br><span class="line"><span class="built_in">exports</span>.name = <span class="string">&quot;A&quot;</span></span><br><span class="line"><span class="keyword">const</span> B = <span class="built_in">require</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(B)</span><br><span class="line"><span class="built_in">exports</span>.data = <span class="string">&quot;Data-A&quot;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B.js</span></span><br><span class="line"><span class="built_in">exports</span>.name = <span class="string">&quot;B&quot;</span></span><br><span class="line"><span class="keyword">const</span> A = <span class="built_in">require</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(A)</span><br><span class="line"><span class="built_in">exports</span>.data = <span class="string">&quot;Data-B&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们执行<code>node A.js</code> 会输出什么？</p>
<p>首先系统会先缓存A模块然后在加载A模块（也就是执行A里面的代码）， 然后当A代码执行到第二行 系统会去require B模块，同A模块一样,系统也是先缓存B模块 然后加载B模块，当B执行到第二行<code>const A = require(&quot;A&quot;)</code>的时候 系统会去加载A模块，但此次我们发现没有？A模块已经在缓存中了，只不过这个A模块还没加载完成 处于一种部分加载的状态。也就是B这里得到的A是个部分值(也就是A.js里在require(‘B’)上方exports出来的值 <code>&#123; name: &quot;A&quot; &#125; </code> )。然后B打印A的部分值<code>&#123; name: &quot;A&quot; &#125;</code> 然后执行最后一行代码后，module B模块加载完毕。此时执行权回到模块A，A这里得到的B是个完全加载的模块<code>&#123; name: &quot;B&quot;, data: &quot;Data-B&quot; &#125;</code> </p>
<p>于是我们可以这样回答这个问题，cjs的模块加载流程是先缓存再加载。基于这个原理我们很容易发现，当出现循环依赖，我们拿到的是一个部分加载模块的部分值。</p>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/2020/02/28/Golang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" class="prev">上一篇</a><a href="/2019/03/03/Dom%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%BD%E9%AB%98%E8%AE%A1%E7%AE%97%E5%80%BC/" class="next">下一篇</a></div><div class="copyright"><p>© 2021 - 2022 <a href="http://narutohinata.github.io">chromer</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"Chromer",'auto');ga('send','pageview');</script></body></html>